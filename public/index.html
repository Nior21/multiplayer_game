<!DOCTYPE html>
<html>

<head>
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* Canvas */
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Header - –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ */
        #header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.7));
            border-bottom: 2px solid gold;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        /* –ù–∏–∫–Ω–µ–π–º —Å —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º */
        #nicknameContainer {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #nicknameDisplay {
            color: gold;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            background: rgba(255, 215, 0, 0.1);
        }

        #nicknameDisplay.editing {
            background: rgba(255, 255, 255, 0.2);
        }

        #nicknameEditBtn {
            background: none;
            border: none;
            color: gold;
            font-size: 14px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
        }

        #nicknameEditBtn:hover {
            background: rgba(255, 215, 0, 0.2);
        }

        /* HP –∏ —â–∏—Ç */
        #healthContainer {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .hp-bar {
            width: 120px;
            height: 20px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #333;
            position: relative;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff4400);
            transition: width 0.3s;
        }

        .shield-fill {
            height: 100%;
            background: linear-gradient(to right, #00aaff, #0088ff);
            position: absolute;
            top: 0;
            left: 0;
        }

        .hp-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            line-height: 20px;
            text-shadow: 1px 1px 2px black;
        }

        /* –°—á–µ—Ç –∏ –∫–Ω–æ–ø–∫–∞ —Å–±—Ä–æ—Å–∞ */
        #scoreContainer {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #scoreDisplay {
            color: white;
            font-size: 16px;
            font-weight: bold;
            min-width: 80px;
        }

        #resetBtn {
            background: linear-gradient(to bottom, #ff4444, #cc0000);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        #resetBtn:active {
            transform: scale(0.95);
        }

        /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        #controlsContainer {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 90;
        }

        /* –î–∂–æ—Å—Ç–∏–∫ */
        #joystick {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            width: 150px;
            height: 150px;
        }

        .joystick-btn {
            background: rgba(255, 255, 255, 0.85);
            border: 3px solid gold;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            transition: all 0.1s;
        }

        .joystick-btn:active,
        .joystick-btn.active {
            background: rgba(255, 215, 0, 0.9);
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        #btnUp {
            grid-column: 2;
            grid-row: 1;
        }

        #btnLeft {
            grid-column: 1;
            grid-row: 2;
        }

        #btnCenter {
            grid-column: 2;
            grid-row: 2;
            background: rgba(255, 255, 255, 0.3);
            border: none;
        }

        #btnDown {
            grid-column: 2;
            grid-row: 3;
        }

        #btnRight {
            grid-column: 3;
            grid-row: 2;
        }

        /* –ü–∞–Ω–µ–ª—å –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–π */
        #spellsPanel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 80px;
            max-height: 60vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px 5px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 2px solid #444;
            scrollbar-width: thin;
            scrollbar-color: gold rgba(0, 0, 0, 0.5);
        }

        #spellsPanel::-webkit-scrollbar {
            width: 6px;
        }

        #spellsPanel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
        }

        #spellsPanel::-webkit-scrollbar-thumb {
            background: gold;
            border-radius: 3px;
        }

        .spell-slot {
            width: 60px;
            height: 60px;
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid #555;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            position: relative;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }

        .spell-slot.selected {
            border-color: gold;
            box-shadow: 0 0 15px gold;
            transform: scale(1.05);
        }

        .spell-slot.empty {
            background: rgba(60, 60, 60, 0.7);
            font-size: 24px;
            color: #888;
        }

        .spell-icon {
            font-size: 18px;
            margin-bottom: 2px;
        }

        .spell-stats {
            font-size: 9px;
            opacity: 0.8;
        }

        /* –ö–Ω–æ–ø–∫–∞ –∫–∞—Å—Ç–∞ */
        #castContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #castButton {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #ff4444, #cc0000);
            border: 4px solid #ff9900;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
            transition: all 0.1s;
            user-select: none;
        }

        #castButton:active {
            transform: scale(0.95);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
        }

        #castHint {
            color: white;
            font-size: 12px;
            opacity: 0.7;
        }

        /* –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(to bottom, #222, #111);
            border: 3px solid gold;
            border-radius: 20px;
            padding: 25px;
            color: white;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
        }

        .modal-title {
            text-align: center;
            margin-bottom: 20px;
            color: gold;
            font-size: 22px;
        }

        .config-slider-container {
            margin: 20px 0;
        }

        .config-slider {
            width: 100%;
            height: 30px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #00aaff, #ffaa00);
            border-radius: 15px;
            outline: none;
        }

        .config-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 40px;
            height: 40px;
            background: gold;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .config-values {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 14px;
        }

        .config-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 25px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-btn.primary {
            background: linear-gradient(to bottom, gold, #ffaa00);
            color: #333;
        }

        .modal-btn.secondary {
            background: linear-gradient(to bottom, #444, #222);
            color: white;
            border: 2px solid #666;
        }

        .modal-btn.danger {
            background: linear-gradient(to bottom, #ff4444, #cc0000);
            color: white;
        }

        .modal-btn:active {
            transform: scale(0.95);
        }

        /* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
        @media (max-width: 768px) {
            #header {
                height: 45px;
                padding: 0 10px;
            }

            #nicknameDisplay {
                font-size: 14px;
            }

            .hp-bar {
                width: 100px;
                height: 18px;
            }

            .hp-text {
                font-size: 11px;
                line-height: 18px;
            }

            #scoreDisplay {
                font-size: 14px;
                min-width: 70px;
            }

            #resetBtn {
                padding: 5px 10px;
                font-size: 13px;
            }

            #joystick {
                width: 140px;
                height: 140px;
            }

            .joystick-btn {
                font-size: 18px;
            }

            #spellsPanel {
                width: 70px;
            }

            .spell-slot {
                width: 55px;
                height: 55px;
                font-size: 10px;
            }

            .spell-icon {
                font-size: 16px;
            }

            #castButton {
                width: 70px;
                height: 70px;
                font-size: 15px;
            }
        }

        @media (max-width: 480px) {
            #header {
                height: 40px;
            }

            #nicknameDisplay {
                font-size: 13px;
                padding: 4px 8px;
            }

            .hp-bar {
                width: 80px;
                height: 16px;
            }

            .hp-text {
                font-size: 10px;
                line-height: 16px;
            }

            #scoreDisplay {
                font-size: 13px;
                min-width: 60px;
            }

            #resetBtn {
                padding: 4px 8px;
                font-size: 12px;
            }

            #controlsContainer {
                padding: 0 10px;
            }

            #joystick {
                width: 130px;
                height: 130px;
            }

            #spellsPanel {
                width: 65px;
            }

            .spell-slot {
                width: 50px;
                height: 50px;
            }

            #castButton {
                width: 65px;
                height: 65px;
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>

        <!-- –®–∞–ø–∫–∞ -->
        <div id="header">
            <div id="nicknameContainer">
                <div id="nicknameDisplay" contenteditable="false">Loading...</div>
                <button id="nicknameEditBtn" title="Edit nickname">‚úèÔ∏è</button>
            </div>

            <div id="healthContainer">
                <div class="hp-bar">
                    <div class="shield-fill" id="shieldFill"></div>
                    <div class="hp-fill" id="hpFill"></div>
                    <div class="hp-text" id="hpText">100/100</div>
                </div>
            </div>

            <div id="scoreContainer">
                <div id="scoreDisplay">Score: 0</div>
                <button id="resetBtn" title="Reset field">üîÑ</button>
            </div>
        </div>

        <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
        <div id="controlsContainer">
            <!-- –î–∂–æ—Å—Ç–∏–∫ -->
            <div id="joystick">
                <div class="joystick-btn" id="btnUp" data-key="up">‚Üë</div>
                <div class="joystick-btn" id="btnLeft" data-key="left">‚Üê</div>
                <div class="joystick-btn" id="btnCenter"></div>
                <div class="joystick-btn" id="btnDown" data-key="down">‚Üì</div>
                <div class="joystick-btn" id="btnRight" data-key="right">‚Üí</div>
            </div>

            <!-- –ö–Ω–æ–ø–∫–∞ –∫–∞—Å—Ç–∞ -->
            <div id="castContainer">
                <button id="castButton">CAST</button>
                <div id="castHint">SPACE</div>
            </div>

            <!-- –ü–∞–Ω–µ–ª—å –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–π -->
            <div id="spellsPanel">
                <div class="spell-slot empty" data-index="0">+</div>
                <div class="spell-slot empty" data-index="1">+</div>
                <div class="spell-slot empty" data-index="2">+</div>
                <div class="spell-slot empty" data-index="3">+</div>
                <div class="spell-slot empty" data-index="4">+</div>
                <div class="spell-slot empty" data-index="5">+</div>
                <div class="spell-slot empty" data-index="6">+</div>
                <div class="spell-slot empty" data-index="7">+</div>
            </div>
        </div>

        <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è -->
        <div id="spellConfigModal" class="modal-overlay">
            <div class="modal-content">
                <h2 class="modal-title" id="modalTitle">Configure Spell</h2>
                <div id="spellTypeDisplay" style="text-align: center; margin-bottom: 20px; font-size: 18px;"></div>

                <div class="config-slider-container">
                    <input type="range" min="1" max="10" value="5" class="config-slider" id="spellConfigSlider">
                    <div class="config-values">
                        <span>Fast ‚ö°</span>
                        <span id="configValues">Speed: 5 / Power: 5</span>
                        <span>Strong üí™</span>
                    </div>
                </div>

                <div class="config-buttons">
                    <button class="modal-btn primary" id="saveSpellBtn">Save</button>
                    <button class="modal-btn secondary" id="cancelSpellBtn">Cancel</button>
                    <button class="modal-btn danger" id="deleteSpellBtn">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const socket = io();

        // Game state
        let myId = '';
        let field = [];
        let FIELD_SIZE = 21;
        let TILE_SIZE = 40;
        let players = {};
        let spells = [];
        let currentConfigIndex = -1;
        let isEditingNickname = false;

        // UI Elements
        const nicknameDisplay = document.getElementById('nicknameDisplay');
        const nicknameEditBtn = document.getElementById('nicknameEditBtn');
        const hpFill = document.getElementById('hpFill');
        const shieldFill = document.getElementById('shieldFill');
        const hpText = document.getElementById('hpText');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const resetBtn = document.getElementById('resetBtn');
        const castButton = document.getElementById('castButton');
        const spellConfigModal = document.getElementById('spellConfigModal');
        const spellConfigSlider = document.getElementById('spellConfigSlider');
        const configValues = document.getElementById('configValues');
        const spellTypeDisplay = document.getElementById('spellTypeDisplay');
        const modalTitle = document.getElementById('modalTitle');
        const saveSpellBtn = document.getElementById('saveSpellBtn');
        const cancelSpellBtn = document.getElementById('cancelSpellBtn');
        const deleteSpellBtn = document.getElementById('deleteSpellBtn');

        // Camera
        let cameraX = 0;
        let cameraY = 0;
        const CAMERA_SMOOTHNESS = 0.1;

        // Initialize canvas size
        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            canvas.width = width;
            canvas.height = height;

            // Recalculate tile size based on screen size
            TILE_SIZE = Math.min(width / FIELD_SIZE, height / FIELD_SIZE) * 0.9;
            TILE_SIZE = Math.max(20, Math.min(50, TILE_SIZE)); // Min 20px, max 50px
        }

        // Update camera to follow player
        function updateCamera() {
            if(!players[myId]) return;

            const player = players[myId];
            const targetX = player.x * TILE_SIZE - canvas.width / 2 + TILE_SIZE / 2;
            const targetY = player.y * TILE_SIZE - canvas.height / 2 + TILE_SIZE / 2;

            // Clamp camera to field bounds
            const maxX = FIELD_SIZE * TILE_SIZE - canvas.width;
            const maxY = FIELD_SIZE * TILE_SIZE - canvas.height;

            cameraX += (Math.max(0, Math.min(targetX, maxX)) - cameraX) * CAMERA_SMOOTHNESS;
            cameraY += (Math.max(0, Math.min(targetY, maxY)) - cameraY) * CAMERA_SMOOTHNESS;
        }

        // Draw functions
        function drawField() {
            if(!field || field.length === 0) return;

            const startX = Math.floor(cameraX / TILE_SIZE);
            const startY = Math.floor(cameraY / TILE_SIZE);
            const endX = Math.ceil((cameraX + canvas.width) / TILE_SIZE);
            const endY = Math.ceil((cameraY + canvas.height) / TILE_SIZE);

            for(let x = Math.max(0, startX); x < Math.min(FIELD_SIZE, endX); x++) {
                for(let y = Math.max(0, startY); y < Math.min(FIELD_SIZE, endY); y++) {
                    const tile = field[x][y];
                    const screenX = x * TILE_SIZE - cameraX;
                    const screenY = y * TILE_SIZE - cameraY;

                    // Draw tile
                    if(tile === 1) {
                        ctx.fillStyle = '#222';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#333';
                        ctx.fillRect(screenX + 2, screenY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    } else if(tile === 2) {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(screenX + 3, screenY + 3, TILE_SIZE - 6, TILE_SIZE - 6);
                    } else {
                        ctx.fillStyle = '#2E8B57';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#3CB371';
                        ctx.fillRect(screenX + 1, screenY + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                    }

                    // Grid
                    ctx.strokeStyle = 'rgba(30, 86, 49, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        function drawPlayers() {
            Object.values(players).forEach(player => {
                const screenX = player.x * TILE_SIZE - cameraX;
                const screenY = player.y * TILE_SIZE - cameraY;

                // Skip if off-screen
                if(screenX + TILE_SIZE < 0 || screenX > canvas.width ||
                    screenY + TILE_SIZE < 0 || screenY > canvas.height) return;

                // Draw player
                ctx.fillStyle = player.color;
                ctx.fillRect(screenX + 4, screenY + 4, TILE_SIZE - 8, TILE_SIZE - 8);

                // Direction indicator
                ctx.fillStyle = 'white';
                const centerX = screenX + TILE_SIZE / 2;
                const centerY = screenY + TILE_SIZE / 2;

                if(player.direction === 'up') {
                    ctx.fillRect(centerX - 2, screenY + 6, 4, 8);
                } else if(player.direction === 'down') {
                    ctx.fillRect(centerX - 2, screenY + TILE_SIZE - 14, 4, 8);
                } else if(player.direction === 'left') {
                    ctx.fillRect(screenX + 6, centerY - 2, 8, 4);
                } else if(player.direction === 'right') {
                    ctx.fillRect(screenX + TILE_SIZE - 14, centerY - 2, 8, 4);
                }

                // Nickname
                ctx.fillStyle = 'white';
                ctx.font = `${Math.max(10, TILE_SIZE / 4)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(player.nickname, centerX, screenY - 8);

                // Selection for current player
                if(player.id === myId) {
                    ctx.strokeStyle = 'gold';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(screenX + 2, screenY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                }
            });
        }

        function drawSpells() {
            spells.forEach(spell => {
                const startX = spell.x * TILE_SIZE - cameraX + TILE_SIZE / 2;
                const startY = spell.y * TILE_SIZE - cameraY + TILE_SIZE / 2;
                const endX = spell.targetX * TILE_SIZE - cameraX + TILE_SIZE / 2;
                const endY = spell.targetY * TILE_SIZE - cameraY + TILE_SIZE / 2;

                const currentX = startX + (endX - startX) * spell.progress;
                const currentY = startY + (endY - startY) * spell.progress;

                // Skip if off-screen
                if(currentX < -20 || currentX > canvas.width + 20 ||
                    currentY < -20 || currentY > canvas.height + 20) return;

                // Draw spell
                ctx.fillStyle = spell.type === 'water' ? '#40C4FF' : '#FFD740';
                ctx.beginPath();
                ctx.arc(currentX, currentY, TILE_SIZE / 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = spell.type === 'water' ? '#2979FF' : '#FFAB00';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function updateSpellSlots() {
            const player = players[myId];
            if(!player) return;

            document.querySelectorAll('.spell-slot').forEach(slot => {
                const index = parseInt(slot.dataset.index);
                const spell = player.spells[index];

                slot.classList.remove('empty', 'selected');
                slot.innerHTML = '';

                if(spell) {
                    if(spell.selected) slot.classList.add('selected');

                    const icon = document.createElement('div');
                    icon.className = 'spell-icon';
                    icon.textContent = spell.type === 'water' ? 'üíß' : 'üõ°Ô∏è';

                    const stats = document.createElement('div');
                    stats.className = 'spell-stats';
                    stats.textContent = `${spell.speed}/${spell.power}`;

                    slot.appendChild(icon);
                    slot.appendChild(stats);
                } else {
                    slot.classList.add('empty');
                    slot.textContent = '+';
                }
            });
        }

        function updateHealthDisplay() {
            const player = players[myId];
            if(!player) return;

            const hpPercent = (player.hp / 100) * 100;
            const shieldPercent = (player.shield / 50) * 100;

            hpFill.style.width = `${hpPercent}%`;
            shieldFill.style.width = `${shieldPercent}%`;
            hpText.textContent = player.shield > 0 ?
                `${player.hp}+${player.shield}/100` :
                `${player.hp}/100`;
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateCamera();
            drawField();
            drawPlayers();
            drawSpells();
            requestAnimationFrame(render);
        }

        // UI Event Handlers
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', resizeCanvas);

            // Nickname editing
            nicknameEditBtn.addEventListener('click', () => {
                if(!isEditingNickname) {
                    isEditingNickname = true;
                    nicknameDisplay.contentEditable = true;
                    nicknameDisplay.classList.add('editing');
                    nicknameDisplay.focus();
                    selectText(nicknameDisplay);
                } else {
                    saveNickname();
                }
            });

            nicknameDisplay.addEventListener('keydown', (e) => {
                if(e.key === 'Enter') {
                    e.preventDefault();
                    saveNickname();
                } else if(e.key === 'Escape') {
                    cancelNicknameEdit();
                }
            });

            nicknameDisplay.addEventListener('blur', saveNickname);

            // Joystick buttons
            document.querySelectorAll('.joystick-btn[data-key]').forEach(btn => {
                const key = btn.dataset.key;

                // Touch events
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleMove(key);
                    btn.classList.add('active');
                });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    btn.classList.remove('active');
                });

                // Mouse events
                btn.addEventListener('mousedown', () => {
                    handleMove(key);
                    btn.classList.add('active');
                });

                btn.addEventListener('mouseup', () => {
                    btn.classList.remove('active');
                });

                btn.addEventListener('mouseleave', () => {
                    btn.classList.remove('active');
                });
            });

            // Spell slots
            document.querySelectorAll('.spell-slot').forEach(slot => {
                const index = parseInt(slot.dataset.index);
                let longPressTimer;

                function handlePress() {
                    const player = players[myId];
                    if(player && player.spells[index]) {
                        socket.emit('selectSpell', index);
                    } else {
                        openSpellConfig(index);
                    }
                }

                // Touch events
                slot.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    longPressTimer = setTimeout(() => {
                        openSpellConfig(index);
                    }, 800);
                });

                slot.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    clearTimeout(longPressTimer);
                    if(longPressTimer) handlePress();
                });

                // Mouse events
                slot.addEventListener('mousedown', () => {
                    longPressTimer = setTimeout(() => {
                        openSpellConfig(index);
                    }, 800);
                });

                slot.addEventListener('mouseup', () => {
                    clearTimeout(longPressTimer);
                    if(longPressTimer) handlePress();
                });

                slot.addEventListener('mouseleave', () => {
                    clearTimeout(longPressTimer);
                });
            });

            // Cast button
            castButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                socket.emit('castSpell');
                castButton.classList.add('active');
            });

            castButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                castButton.classList.remove('active');
            });

            castButton.addEventListener('mousedown', () => {
                socket.emit('castSpell');
                castButton.classList.add('active');
            });

            castButton.addEventListener('mouseup', () => {
                castButton.classList.remove('active');
            });

            // Reset button
            resetBtn.addEventListener('click', () => {
                if(confirm('Reset the game field?')) {
                    socket.emit('resetField');
                }
            });

            // Spell config modal
            spellConfigSlider.addEventListener('input', updateConfigDisplay);
            saveSpellBtn.addEventListener('click', saveSpellConfig);
            cancelSpellBtn.addEventListener('click', closeSpellConfig);
            deleteSpellBtn.addEventListener('click', deleteSpellConfig);

            // Keyboard controls
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        function handleKeyDown(e) {
            if(!myId) return;

            // Movement
            const keyMap = {
                'ArrowUp': 'up', 'w': 'up', 'W': 'up', '—Ü': 'up', '–¶': 'up',
                'ArrowDown': 'down', 's': 'down', 'S': 'down', '—ã': 'down', '–´': 'down',
                'ArrowLeft': 'left', 'a': 'left', 'A': 'left', '—Ñ': 'left', '–§': 'left',
                'ArrowRight': 'right', 'd': 'right', 'D': 'right', '–≤': 'right', '–í': 'right'
            };

            if(keyMap[e.key]) {
                socket.emit('move', keyMap[e.key]);
                highlightButton(keyMap[e.key]);
            }

            // Cast spell
            if(e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                socket.emit('castSpell');
                castButton.classList.add('active');
            }

            // Spell selection (1-8)
            if(e.key >= '1' && e.key <= '8') {
                const index = parseInt(e.key) - 1;
                if(players[myId] && players[myId].spells[index]) {
                    socket.emit('selectSpell', index);
                    highlightSpellSlot(index);
                }
            }

            // Escape nickname edit
            if(e.key === 'Escape' && isEditingNickname) {
                cancelNicknameEdit();
            }
        }

        function handleKeyUp(e) {
            // Movement keys
            const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
                'w', 'W', 's', 'S', 'a', 'A', 'd', 'D',
                '—Ü', '–¶', '—ã', '–´', '—Ñ', '–§', '–≤', '–í'];
            if(movementKeys.includes(e.key)) {
                document.querySelectorAll('.joystick-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
            }

            // Space bar
            if(e.key === ' ' || e.key === 'Spacebar') {
                castButton.classList.remove('active');
            }
        }

        function highlightButton(direction) {
            const btnId = {
                'up': 'btnUp',
                'down': 'btnDown',
                'left': 'btnLeft',
                'right': 'btnRight'
            }[direction];

            if(btnId) {
                const btn = document.getElementById(btnId);
                if(btn) {
                    btn.classList.add('active');
                    setTimeout(() => btn.classList.remove('active'), 100);
                }
            }
        }

        function highlightSpellSlot(index) {
            const slots = document.querySelectorAll('.spell-slot');
            if(slots[index]) {
                const originalTransform = slots[index].style.transform;
                slots[index].style.transform = 'scale(1.1)';
                setTimeout(() => {
                    slots[index].style.transform = originalTransform;
                }, 300);
            }
        }

        function handleMove(direction) {
            socket.emit('move', direction);
        }

        function selectText(element) {
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function saveNickname() {
            if(!isEditingNickname) return;

            const newNickname = nicknameDisplay.textContent.trim();
            if(newNickname.length > 0 && newNickname.length <= 12) {
                socket.emit('rename', newNickname);
            } else {
                // Restore original
                const player = players[myId];
                if(player) nicknameDisplay.textContent = player.nickname;
            }

            cancelNicknameEdit();
        }

        function cancelNicknameEdit() {
            isEditingNickname = false;
            nicknameDisplay.contentEditable = false;
            nicknameDisplay.classList.remove('editing');
            const player = players[myId];
            if(player) nicknameDisplay.textContent = player.nickname;
        }

        function openSpellConfig(index) {
            currentConfigIndex = index;
            const player = players[myId];
            const spell = player ? player.spells[index] : null;

            if(spell) {
                modalTitle.textContent = 'Edit Spell';
                spellTypeDisplay.textContent = spell.type === 'water' ? 'Water Blast üíß' : 'Shield üõ°Ô∏è';
                spellConfigSlider.value = spell.speed;
                deleteSpellBtn.style.display = 'block';
            } else {
                modalTitle.textContent = 'Create Spell';
                spellTypeDisplay.textContent = 'Select Spell Type';
                spellConfigSlider.value = 5;
                deleteSpellBtn.style.display = 'none';
            }

            updateConfigDisplay();
            spellConfigModal.classList.add('active');
        }

        function updateConfigDisplay() {
            const speed = parseInt(spellConfigSlider.value);
            const power = 11 - speed;
            configValues.textContent = `Speed: ${speed} / Power: ${power}`;
        }

        function closeSpellConfig() {
            spellConfigModal.classList.remove('active');
            currentConfigIndex = -1;
        }

        function saveSpellConfig() {
            if(currentConfigIndex === -1) return;

            const type = players[myId]?.spells[currentConfigIndex]?.type || 'water';
            const speed = parseInt(spellConfigSlider.value);
            const power = 11 - speed;

            socket.emit('updateSpell', {
                index: currentConfigIndex,
                type: type,
                speed: speed,
                power: power,
                selected: true
            });

            closeSpellConfig();
        }

        function deleteSpellConfig() {
            if(currentConfigIndex === -1) return;

            socket.emit('updateSpell', {
                index: currentConfigIndex,
                type: null,
                speed: 0,
                power: 0,
                selected: false
            });

            closeSpellConfig();
        }

        // Socket events
        socket.on('init', (data) => {
            console.log('Game initialized');
            myId = data.id;
            field = data.field || [];
            FIELD_SIZE = data.fieldSize || 21;
            players = data.allPlayers || {};
            spells = data.allSpells || [];

            nicknameDisplay.textContent = data.nickname;
            scoreDisplay.textContent = `Score: ${players[myId]?.score || 0}`;
            updateHealthDisplay();
            updateSpellSlots();

            // Initialize camera
            if(players[myId]) {
                cameraX = players[myId].x * TILE_SIZE - canvas.width / 2 + TILE_SIZE / 2;
                cameraY = players[myId].y * TILE_SIZE - canvas.height / 2 + TILE_SIZE / 2;
            }

            resizeCanvas();
            setupEventListeners();
            render();
        });

        socket.on('playerJoined', (player) => {
            players[player.id] = player;
        });

        socket.on('playerMoved', (data) => {
            if(players[data.id]) {
                players[data.id].x = data.x;
                players[data.id].y = data.y;
                players[data.id].direction = data.direction;
            }
        });

        socket.on('playerUpdated', (player) => {
            players[player.id] = player;
            if(player.id === myId) {
                nicknameDisplay.textContent = player.nickname;
                scoreDisplay.textContent = `Score: ${player.score}`;
                updateHealthDisplay();
                updateSpellSlots();
            }
        });

        socket.on('spellCast', (spell) => {
            spells.push(spell);
        });

        socket.on('spellsUpdate', (updatedSpells) => {
            spells = updatedSpells;
        });

        socket.on('blockDestroyed', (data) => {
            if(field[data.x] && field[data.x][data.y] === 2) {
                field[data.x][data.y] = 0;
            }
        });

        socket.on('blockRespawned', (data) => {
            if(field[data.x] && field[data.x][data.y] === 0) {
                field[data.x][data.y] = 2;
            }
        });

        socket.on('fieldReset', (newField) => {
            field = newField;
        });

        socket.on('playerLeft', (playerId) => {
            delete players[playerId];
        });

        // Initialize
        resizeCanvas();
        setupEventListeners();
        render();
    </script>
</body>

</html>